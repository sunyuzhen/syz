## java基础（第一天）

## 1. String 、StringBuffer和StringBuilder的区别是什么

三个角度来说吧 ，

第一个就是可变和不可变的角度

String 是属于 finnal修饰符修饰的 所以它是不可变的，

StringBuffer 和StringBuilder 这俩都是继承 AbstractStringBuilder 类的 AbstractStringBuilder 是由字符数组保存的所以是可变的

线程安全的角度

String 是不可变的 所以线程是安全的

StringBuffer 对方法加了同步锁，或者对调用的方法加了同步锁，所以线程是安全的

StringBuilder 是非线程安全的

执行效率

String是最慢的，因为String是不可变的 所以每次修改它的话 都是重新生成一个String对象然后 再把指针指向新生成的对象，不仅效率低还浪费内存空间

StringBuilder 比StringBuffer效率更高一些



## 2.hashcode()和equals()

hashcode() 其实主要是查 哈希码 是一个int整数，这个是记录对象在哈希表上的索引位置的，

比如说 当你把对象放在hashset上  hashset会先通过hashcode 值来判断对象的加入位置，并且和set中的其他对象的hashcode值做比较，如果没有一样的，hashset会假设对象没有重复出现。

如果出现了hashcode值一样的情况，那么需要用equals方法来判断 两个对象的值是否相等，如果相等的话则不加入到set中。

hashcode值一样的情况下，两个对象不一定相等，但如果两个对象 equals ，他们的hashset值一定相等。

重写 equals 方法的话，一定要重写 hashcode方法，因为判断两个对象是否相等的情况是先来对比hashcode值是否相等，再用equals方法，如果不重写hashcode方法的话有可能会出现，equals 相等但是hashcode值不相等的情况。 

## 3. == 和 equals 区别

== 对比的一般是对象的内存地址是否相等，来判断是否是一个对象，如果是基本类型的话对比的是值，如果是引用数据类型的话 ，则判断的是对象的内存地址。

equals的话 如果类没有重写equals方法的话，其实等价于 == 就是通过变量的引用的对象的内存地址来判断是否为一个对象 因为object中的equals方法就是判断对象的内存地址。

基本类型不能用equals 方法

一般类都会重写equals方法来判断 对象的值，比如说String类 的equals方法就是判断对象的值是否相等。

## 4. jdk jre jvm 的联系与区别是什么

**jdk**

java开发工具包，除了包含jre以外，还包含了开发Java程序所必须的编译，调试，运行命令工具。

**jre**

   是java运行环境 它包含jvm 还有 java核心类库

所有Java程序都需要再jre下才能运行，如果是普通用户已经开发好的Java程序，那么直接安装jre就可以运行

**jvm**

Java 虚拟机 负责 加载 和解析 字节码文件 也就是.class文件。  它也是Java可以跨平台运行的核心。

Java语言最重要的特点就是跨平台，使用jvm就是为了避免支持与操作系统无关，实现跨平台



## 5. 字符型常量和字符串型常量的关系

也是从三个方面说把

从形态上看，字符型常量 是由单引号扩起来的单字符， 字符串型常量是由 双引号括起来的若干个字符

从含义上来看，字符型常量相当于一个整型值ASCII码，可以参加表达式运算，字符串型常量代表的是一个地址值 （该字符串在内存中存放的位置）

从大小来看 字符型常量只占2个字符 ，字符串型常量占若干个字符。

## 6.构造器是否可以被重写？

构造器不可以被重写，但是它可以被重载，所以你可以看到一个类中有多个构造器的情况



## 7.什么是反射

反射是指 在运行时可以动态的获取类的信息，获取class对象有三种方法：类名.class  对象名.getClass  Class.forName("全限定名")

获取到类对象后可以用newInstance()创建对象，Class类中API提供了获取属性、方法、构造器的方法。



## 8.装箱和拆箱

装箱：将基本数据类型转换为包装类类型

拆箱：将包装类类型转换为基本数据类型



## 9.关于finnal关键字的一些总结

finnal主要用在3个地方，变量 ，方法，类

一个finnal变量 如果它是基本类型变量的话，那么数据一旦初始化后就不能再被修改，如果是引用类型的变量，那么它一旦初始化后就不能再指向另一个对象。

当用finnal修饰一个方法的时候，这个方法不能被重写。

当用finnal修饰一个类的时候，这个类不能被其他类继承，这个类中的方法成员也会被隐式的指定为finnal方法